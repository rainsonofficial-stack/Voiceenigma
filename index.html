<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <!-- PWA CRITERIA: Manifest Link -->
    <title>OS | AOD Discreet Magic</title> 
    <link rel="manifest" href="./manifest.json">
    <link rel="apple-touch-icon" href="/icon-180x180.png">
    
    <!-- Loads external CSS for styling -->
    <style>
        /* AOD Styling (Minimal, Discreet, Dark) */
        html, body {
            margin: 0;
            padding: 0;
            font-family: Inter, -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
            overflow: hidden; 
            height: 100%;
            background: #000;
        }

        #app {
            width: 100%;
            height: 100%;
            max-width: 600px;
            max-height: 100vh;
            position: relative;
            background: #000;
            display: flex;
            flex-direction: column;
            align-items: center;
            user-select: none;
            color: #c4c4c4; 
            box-sizing: border-box;
            /* Position adjusted in previous step */
            padding-top: 180px; 
            padding-bottom: 30px; 
        }
        
        /* Container for Tap Area */
        #clock-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            z-index: 10;
            padding: 20px; 
            margin: -20px; 
            -webkit-tap-highlight-color: transparent; 
            outline: none; 
        }

        /* Clock Widget */
        .time-display {
            font-size: 80px;
            font-weight: 300;
            margin-bottom: 5px;
            color: #ffffff; 
            -webkit-tap-highlight-color: transparent; 
        }
        .date-display {
            font-size: 16px;
            font-weight: 400;
            margin-bottom: 25px;
            color: #c4c4c4; 
            -webkit-tap-highlight-color: transparent;
        }

        /* --- Notification Bar --- */
        #system-notification {
            width: 90%;
            max-width: 300px; 
            padding: 5px 10px; 
            background: #282a2d; 
            border-radius: 6px; 
            display: flex;
            align-items: center; 
            transition: opacity 0.5s;
            margin-top: 10px; 
            min-height: 30px; 
        }
        .notif-icon-svg {
            margin-right: 6px; 
            color: #c4c4c4; 
            width: 14px; 
            height: 14px;
            line-height: 1;
            flex-shrink: 0;
            transition: transform 0.5s;
        }
        .final-word-placeholder {
            color: #ffffff; 
            font-weight: 500; 
            letter-spacing: 0.5px;
        }
        .notif-text {
            font-size: 12px; 
            color: #d1d1d1;
            font-weight: 500; 
            word-break: break-word; 
            line-height: 1.3;
            white-space: normal;
            flex-grow: 1;
            text-align: center; 
        }
        
        /* Transcript Widget (Debug) */
        #transcript-widget {
            width: 90%;
            max-width: 400px;
            background: rgba(40, 42, 45, 0.8);
            color: #d1d1d1; 
            font-size: 10px;
            padding: 8px;
            margin: 15px 0;
            border-radius: 6px;
            max-height: 150px;
            overflow-y: auto;
            display: none; 
            box-shadow: 0 0 10px rgba(0, 0, 0, 0.5);
            line-height: 1.4;
            flex-shrink: 0;
            white-space: pre-wrap;
        }

        /* Listening State Styles */
        .listening-active {
            animation: pulse-mic 1.5s infinite;
        }
        @keyframes pulse-mic {
            0% { transform: scale(1); opacity: 0.6; }
            50% { transform: scale(1.1); opacity: 1; }
            100% { transform: scale(1); opacity: 0.6; }
        }

        /* --- Bottom Icons Container --- */
        #bottom-icons {
            position: absolute;
            bottom: 30px;
            width: 90%;
            max-width: 380px; 
            display: flex;
            justify-content: space-between;
            align-items: flex-end; 
            box-sizing: border-box;
            padding: 0 10px;
            margin-top: auto; 
        }
        
        /* --- Spotify Widget --- */
        #music-player {
            flex-grow: 1;
            max-width: 250px; 
            min-width: 150px;
            padding: 8px; 
            background: rgba(255, 255, 255, 0.1); 
            backdrop-filter: blur(5px);
            border-radius: 12px;
            display: flex;
            align-items: center;
            margin: 0 10px; 
            box-sizing: border-box;
        }

        .album-art {
            width: 30px; 
            height: 30px;
            background: #4f5358;
            border-radius: 6px;
            margin-right: 10px;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        .album-art svg {
            width: 16px;
            height: 16px;
        }
        .song-info {
            flex-grow: 1;
            overflow: hidden;
            white-space: nowrap;
        }
        .song-title {
            color: white;
            font-weight: 600;
            font-size: 13px; 
            margin-bottom: 2px;
        }
        .song-artist {
            font-size: 11px; 
            color: #c4c4c4;
        }
        .timeline {
            margin-left: 10px;
            font-size: 12px;
            flex-shrink: 0;
        }
        #current-second {
            color: white;
            font-weight: 600;
        }
        
        .bottom-icon {
            width: 40px;
            height: 40px;
            border-radius: 50%;
            background: rgba(255, 255, 255, 0.05);
            display: flex;
            align-items: center;
            justify-content: center;
            color: #c4c4c4;
            cursor: pointer;
            flex-shrink: 0;
        }
    </style>
</head>
<body>
    <div id="app">
        <!-- Clock Container (Expanded Tap Target) -->
        <div id="clock-container">
            <div class="time-display" id="aod-time"></div>
            <div class="date-display" id="aod-date"></div>
        </div>

        <!-- System Notification (Used for Word List / Final Word Reveal) -->
        <div id="system-notification">
            <div class="notif-icon-svg" id="notif-icon">
                <!-- Initial Gear SVG -->
                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M12 20v-8M20 12h-8M4 12h8M12 4v8M18.36 5.64l-4.24 4.24M5.64 18.36l4.24-4.24M18.36 18.36l-4.24-4.24M5.64 5.64l4.24 4.24"></path></svg>
            </div>
            <div class="notif-text" id="notif-text">System Update Available</div>
        </div>

        <!-- Debug Transcript Widget -->
        <div id="transcript-widget">
            Ready. Double-tap blank area to hide/show.
        </div>

        <!-- Bottom Icons and Music Player -->
        <div id="bottom-icons">
            <div class="bottom-icon" title="Phone">
                <svg viewBox="0 0 24 24" width="20" height="20" stroke="currentColor" stroke-width="2" fill="none" stroke-linecap="round" stroke-linejoin="round"><path d="M22 16.92v3a2 2 0 0 1-2.18 2 19.79 19.79 0 0 1-8.63-3.07 19.5 19.5 0 0 1-6-6 19.79 19.79 0 0 1-3.07-8.63A2 2 0 0 1 4.08 2h3a2 2 0 0 1 2 1.72 12.84 12.84 0 0 0 .7 2.81 2 2 0 0 1-.45 2.11L8.09 9.91a16 16 0 0 0 6 6l1.27-1.27a2 2 0 0 1 2.11-.45 12.84 12.84 0 0 0 2.81.7A2 2 0 0 1 22 16.92z"></path></svg>
            </div>
            
            <!-- Music Player Widget -->
            <div id="music-player">
                <div class="album-art">
                    <!-- Music Note SVG Icon -->
                    <svg viewBox="0 0 24 24" stroke="white" stroke-width="2" fill="none" stroke-linecap="round" stroke-linejoin="round"><path d="M9 18V5l12-2v13"></path><circle cx="6" cy="18" r="3"></circle><circle cx="18" cy="16" r="3"></circle></svg>
                </div>
                <div class="song-info">
                    <div class="song-title">Shape of You</div>
                    <div class="song-artist">Ed Sheeran</div>
                </div>
                <div class="timeline">
                    0:<span id="current-second">00</span>
                </div>
            </div>

            <div class="bottom-icon" title="Camera">
                <svg viewBox="0 0 24 24" width="20" height="20" stroke="currentColor" stroke-width="2" fill="none" stroke-linecap="round" stroke-linejoin="round"><path d="M23 19a2 2 0 0 1-2 2H3a2 2 0 0 1-2-2V8a2 2 0 0 1 2-2h4l2-3h6l2 3h4a2 2 0 0 1 2 2z"></path><circle cx="12" cy="13" r="4"></circle></svg>
            </div>
        </div>
    </div>
    
    <!-- Load the external dictionary file -->
    <script src="./large_dictionary.js"></script> 
    
    <!-- Load the main application logic -->
    <script>
        // NOTE: The LARGE_DICTIONARY constant is expected to be loaded via large_dictionary.js
        
        const APP = {
            // Configuration
            PASSCODE_LENGTH: 4,
            // MINIMAL RESTART DELAY: Set to 10ms for instant restart after command processing.
            RESTART_DELAY_MS: 10, 
            SESSION_KEY: 'aod_magic_state',
            
            // State Variables
            APP_STATE: 'AOD_LOCK', 
            isListening: false,     
            MATCHES: [], 
            HISTORY: [], 
            CURRENT_POSITION_INDEX: 0, 
            recognizer: null,

            // D4 Shape Definitions (A-Z split into 3 groups based on first letter shape)
            LETTER_SHAPES: {
                1: new Set('AEFHIKLMNTVWXYZ'.split('')), // Straight lines/corners
                2: new Set('BDGJPRU'.split('')),         // Curved/Mixed lines
                3: new Set('COS'.split('')),             // Circular/Round shapes
            },

            // D4 Trigger Words (1 = Word/Walk/Watch, 2 = Different, 3 = Option)
            D4_TRIGGERS: {
                'WORD': 1, 'WORDS': 1,
                'WALK': 1, 
                'WATT': 1, 'WATTS': 1, 
                'WATCH': 1, 
                'DIFFERENT': 2,
                'OPTION': 3, 'OPTIONS': 3,
            },

            // Single-digit and 'teen' number word mapping for D1, D2, D3 extraction
            NUMBER_WORDS: {
                'ZERO': 0, // Supports 'ZERO' word
                'ONE': 1, 'TWO': 2, 'THREE': 3, 'FOUR': 4, 
                'FIVE': 5, 'SIX': 6, 'SEVEN': 7, 'EIGHT': 8, 'NINE': 9,
                // Teens only provide the D1 number
                'TEN': 1, 'ELEVEN': 1, 'TWELVE': 2, 'THIRTEEN': 3, 'FOURTEEN': 4,
                'FIFTEEN': 5, 'SIXTEEN': 6, 'SEVENTEEN': 7, 'EIGHTEEN': 8, 'NINETEEN': 9,
                
                // Homophones and common phonetic errors
                'WAN': 1, 'WON': 1, 'WANT': 1, 'WAND': 1, 'WONDER': 1, 
                'TO': 2, 'TOO': 2, 
                'TREE': 3, 'FREE': 3, 
                'FOR': 4, 
                'FINE': 5, 
                'SEX': 6, 
                'ATE': 8, 'EIGHT': 8, 'I': 8, 'EYE': 8, 'HEIGHT': 8, 
                'IT': 8, 
            },

            // SVG Icons
            ICON_GEAR_SVG: `<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M12 20v-8M20 12h-8M4 12h8M12 4v8M18.36 5.64l-4.24 4.24M5.64 18.36l4.24-4.24M18.36 18.36l-4.24-4.24M5.64 5.64l4.24 4.24"></path></svg>`,
            ICON_CHAT_SVG: `<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 15a2 2 0 0 1-2 2H7l-4 4V5a2 2 0 0 1 2-2h14a2 2 0 0 1 2 2z"></path></svg>`,

            // --- State Persistence ---
            saveState() {
                try {
                    const stateToSave = {
                        matches: this.MATCHES,
                        history: this.HISTORY,
                        position: this.CURRENT_POSITION_INDEX,
                        state: this.APP_STATE
                    };
                    sessionStorage.setItem(this.SESSION_KEY, JSON.stringify(stateToSave));
                } catch (e) {
                    this.logStatus(`Error saving state: ${e.message}`, true);
                }
            },

            loadState() {
                try {
                    const savedState = sessionStorage.getItem(this.SESSION_KEY);
                    if (savedState) {
                        const state = JSON.parse(savedState);
                        this.MATCHES = state.matches || [];
                        this.HISTORY = state.history || [];
                        this.CURRENT_POSITION_INDEX = state.position || 0;
                        this.APP_STATE = state.state || 'AOD_LOCK';

                        if (this.MATCHES.length > 0 && this.APP_STATE !== 'AOD_DISPLAY_FINAL') {
                            this.logStatus("State loaded. Attempting to resume puzzle.");
                            this.APP_STATE = 'AOD_LISTENING'; // Set state for listening start
                            this.updateNotification('WORD_LIST');
                            return true; // Indicates successful resume
                        }
                    }
                } catch (e) {
                    this.logStatus(`Error loading state: ${e.message}. Starting fresh.`, true);
                    sessionStorage.removeItem(this.SESSION_KEY);
                }
                return false; // Indicates start from scratch
            },

            clearState() {
                sessionStorage.removeItem(this.SESSION_KEY);
                this.logStatus("Cleared session state.");
            },
            
            // --- Voice Recognition Control (Continuous Listening) ---
            startListening() {
                if (this.isListening) {
                    if (this.recognizer) {
                        this.logStatus("Attempted to start listening, but already active. Current lang: " + this.recognizer.lang);
                    }
                    return;
                }

                this.isListening = true;
                if (this.APP_STATE === 'AOD_LOCK') {
                    this.APP_STATE = 'AOD_LISTENING';
                }
                this.updateListeningUI(true); 
                
                try {
                    if (!this.recognizer) {
                        this.logStatus("Recognizer not initialized. Cannot start listening.", true);
                        this.isListening = false;
                        return;
                    }
                    // No need to abort here, let the browser handle state changes via its error/end handlers
                    // this.recognizer.abort(); 
                    this.recognizer.start();
                    this.logStatus("Started continuous listening session. Recognizer language set to: " + this.recognizer.lang);
                } catch (e) {
                    if (e.name === 'InvalidStateError') {
                        this.logStatus("Recognizer is already active. Ignoring redundant start. (Handled by try/catch)", true);
                        this.isListening = true;
                        this.updateListeningUI(true);
                        return;
                    }
                    this.logStatus(`Error starting recognition: ${e.message}. (Likely mic permission issues)`, true);
                    this.isListening = false;
                    this.updateListeningUI(false);
                }
            },
            
            stopListening() {
                // Permanently stops the mic (for final word reveal or hard reset)
                this.isListening = false;
                this.APP_STATE = 'AOD_DISPLAY_FINAL'; 
                this.updateListeningUI(false); 
                try {
                    if (this.recognizer) this.recognizer.abort(); 
                    this.logStatus("Stopped continuous listening permanently.");
                } catch (e) {}
            },

            updateListeningUI(isActive) {
                const notifIcon = document.getElementById('notif-icon');
                
                if (isActive) {
                    notifIcon.classList.add('listening-active'); 
                } else {
                    notifIcon.classList.remove('listening-active'); 
                }
            },

            initVoiceRecognition() {
                const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;

                if (!SpeechRecognition) {
                    this.logStatus("Speech Recognition not supported.", true);
                    return;
                }
                
                this.recognizer = new SpeechRecognition();
                // continuous = true allows for longer pauses within a thought/sentence.
                this.recognizer.continuous = true; 
                this.recognizer.interimResults = false;
                this.recognizer.lang = 'en-US'; 
                this.logStatus("Voice Recognizer initialized. Target language: " + this.recognizer.lang);
                
                this.recognizer.onstart = () => { 
                    this.logStatus("Recognizing..."); 
                    this.updateListeningUI(true);
                    this.isListening = true;
                };

                this.recognizer.onend = () => {
                    this.isListening = false; 

                    if (this.APP_STATE !== 'AOD_DISPLAY_FINAL') {
                        // Restart handles the loop, set to MINIMAL delay for instant transition.
                        this.logStatus(`Listening session ended. Recognizer state: ${this.recognizer.readyState}. Restarting instantly...`);
                        setTimeout(() => this.startListening(), this.RESTART_DELAY_MS);
                    } else {
                        this.logStatus("Listening ended. Remaining in AOD_DISPLAY_FINAL state.");
                        this.updateListeningUI(false);
                    }
                };

                this.recognizer.onerror = (event) => {
                    this.logStatus(`Voice Error (${event.error}).`, true);
                    if (event.error === 'not-allowed' || event.error === 'service-not-allowed') {
                        this.isListening = false;
                        this.updateListeningUI(false);
                        this.APP_STATE = 'AOD_LOCK'; 
                    }
                };
                
                this.recognizer.onresult = (event) => {
                    const rawTranscript = event.results[0][0].transcript.trim();
                    const upperTranscript = rawTranscript.toUpperCase();
                    
                    const widget = document.getElementById('transcript-widget');
                    if (widget) {
                        const isInitialText = widget.textContent.includes("Ready. Double-tap");
                        widget.textContent = (isInitialText ? '' : widget.textContent + '\n') + rawTranscript;
                        widget.scrollTop = widget.scrollHeight; 
                    }

                    this.logStatus(`RAW Transcript received: "${upperTranscript}"`); 
                    
                    // CRITICAL: Manually stop the continuous session after receiving a result.
                    // This forces onend to fire, which then restarts the mic for a fresh session.
                    this.logStatus("Result received. Stopping session for processing and instant restart via onend.");
                    this.recognizer.abort(); 

                    if (this.MATCHES.length === 0) {
                        this.handleInitialPasscode(upperTranscript);
                    } else {
                        this.handleLetterInput(upperTranscript);
                    }
                };
            },
            
            // --- UI/Helper Functions ---
            
            updateTime() {
                const now = new Date();
                let hours = now.getHours();
                const minutes = now.getMinutes().toString().padStart(2, '0');
                
                hours = hours % 12;
                hours = hours ? hours : 12; 
                
                const time = `${hours}:${minutes}`; 
                const date = now.toLocaleDateString('en-US', { weekday: 'long', month: 'long', day: 'numeric' });

                const timeEl = document.getElementById('aod-time');
                const dateEl = document.getElementById('aod-date');

                if (timeEl) timeEl.textContent = time;
                if (dateEl) dateEl.textContent = date;
            },

            getVowelIndices(word) {
                const indices = [];
                for (let i = 0; i < word.length; i++) {
                    if (word[i].toUpperCase().match(/[AEIOU]/)) {
                        indices.push(i + 1); // 1-based position
                    }
                }
                return indices;
            },

            /**
             * Single Tap: Ensures mic is active, especially after suspension/reopen.
             */
            handleSingleTap(event) {
                if (!this.recognizer) {
                    this.logStatus("Single Tap: Recognizer not initialized.", true);
                    return;
                }

                if (this.APP_STATE === 'AOD_DISPLAY_FINAL') {
                    this.logStatus("Single Tap: In final display state (Ignored).");
                    return;
                }
                
                const readyState = this.recognizer.readyState;
                this.logStatus(`Single Tap detected. Recognizer readyState: ${readyState}, isListening flag: ${this.isListening}`);

                // If the readyState is not 'listening' (i.e., 'idle' or 'closed'), force a restart.
                // We reset the flag here just in case it was stuck by the browser.
                if (readyState !== 'listening') {
                    this.isListening = false;
                    this.logStatus("Forcing mic restart (readyState was not 'listening').");
                    this.startListening(); 
                } else {
                    this.logStatus("Mic is already active ('listening'). Tap ignored.");
                }
            },

            // Master reset on double-tap 
            handleDoubleTap(event) {
                this.logStatus("Double Tap: Master Reset.");
                this.resetApp(true); 
            },
            
            // Toggle Transcript Widget
            toggleTranscriptWidget(event) {
                // Ignore double clicks on the clock container as that is the master reset
                if (event.target.closest('#clock-container') || event.target.closest('#music-player')) {
                    return; 
                }
                
                const widget = document.getElementById('transcript-widget');
                if (widget) {
                    const isHidden = widget.style.display === 'none' || widget.style.display === '';
                    widget.style.display = isHidden ? 'block' : 'none';
                    this.logStatus(`Transcript widget ${isHidden ? 'shown' : 'hidden'}.`);
                }
            },
            
            // --- Core Logic (Filter functions) ---
            filterDictionary(d1, d2, d3, d4, initialList) {
                if (typeof initialList === 'undefined' || !Array.isArray(initialList) || initialList.length === 0) { 
                    this.logStatus("Dictionary not initialized or empty during filtering in filterDictionary.", true);
                    return []; 
                } 
                
                const dictionary = initialList.map(w => w.toUpperCase());
                
                return dictionary.filter(word => {
                    const length = word.length;
                    const vIndices = this.getVowelIndices(word);
                    const firstLetter = word[0];

                    // D1 (Word Length)
                    if (d1 === 0) {
                        // D1=0 means EXACTLY 10 letters
                        if (length !== 10) return false;
                    } else {
                        // D1=X (1-9) means X OR X+10 letters
                        if (length !== d1 && length !== (d1 + 10)) return false;
                    }
                    
                    // D2 (First Vowel Position)
                    // D2=0 is the wildcard (as confirmed by the user in a previous step)
                    if (d2 > 0 && (vIndices.length < 1 || vIndices[0] !== d2)) return false;
                    
                    // D3 (Second Vowel Position)
                    // D3=0 is the wildcard
                    if (d3 > 0 && (vIndices.length < 2 || vIndices[1] !== d3)) return false;
                    
                    // D4 (First Letter Shape)
                    if (d4 > 0) {
                        const shapeSet = this.LETTER_SHAPES[d4];
                        if (!shapeSet || !shapeSet.has(firstLetter)) return false;
                    }
                    return true;
                });
            },
            
            getDisambiguationIndex(matches) {
                if (matches.length <= 1) return 0; 
                
                // Determine the minimum length among all matched words
                const minLength = Math.min(...matches.map(w => w.length));
                let bestIndex = 0; 
                let maxUniqueLetters = 0; 

                // Check every position up to the minimum length of all matched words
                for (let i = 0; i < minLength; i++) {   
                    const lettersAtPosition = matches
                        .map(word => word.length > i ? word[i] : null)
                        .filter(l => l !== null);
                    
                    const uniqueCount = new Set(lettersAtPosition).size;

                    // Update if the current position has strictly MORE unique letters
                    if (uniqueCount > maxUniqueLetters) { 
                        maxUniqueLetters = uniqueCount;
                        bestIndex = i + 1; // 1-based index
                    }
                }
                return bestIndex;
            },

            // --- Handlers ---
            
            handleInitialPasscode(transcript) {
                let d4 = 0;
                let numbers = [];
                // Clean up punctuation and split words
                const rawWords = transcript.split(' ').map(w => w.trim()).filter(w => w.length > 0);
                
                for (const w of rawWords) {
                    const cleanWord = w.replace(/[.,\/#!$%\^&\*;:{}=\-_`~()]/g,"").toUpperCase();
                    
                    // 1. Check D4 Trigger (use the clean word)
                    const triggerValue = this.D4_TRIGGERS[cleanWord];
                    if (triggerValue) { d4 = triggerValue; }
                    
                    // --- DUAL CHECK (D2=1, D3=2) ---
                    if (cleanWord === 'DUAL') {
                        numbers.push(1);
                        numbers.push(2);
                        continue;
                    }
                    // --- END DUAL CHECK ---

                    // 2. Check for number words (use the clean word)
                    // Treat "DOT" or "POINT" as the number 1
                    if (cleanWord === 'DOT' || cleanWord === 'POINT') {
                        numbers.push(1);
                        continue;
                    }
                    const spelled = this.NUMBER_WORDS[cleanWord];
                    if (spelled !== undefined) { // Check for undefined (allows 0)
                        numbers.push(spelled);
                        continue;
                    } 
                    
                    // 3. Check for raw digits or floating point numbers (use the raw word)
                    if (/^\d+(\.\d+)?$/.test(w)) {
                        // Handle cases like '924' being transcribed as one word
                        for (const char of w) {
                            if (char === '.') {
                                numbers.push(1); // '.' is interpreted as 1
                            } else {
                                const digit = parseInt(char, 10);
                                if (digit >= 0 && digit <= 9) { // NOW accepts 0
                                    numbers.push(digit);
                                }
                            }
                        }
                        continue;
                    }
                }
                
                this.logStatus(`DEBUG: Numbers Parsed: [${numbers.join(', ')}] (Length: ${numbers.length}), D4 Trigger Value: ${d4}`);

                let d1, d2, d3;

                // --- CRITICAL FAILURE CHECKS AND D1, D2, D3 ASSIGNMENT ---
                if (d4 === 0) {
                    this.logStatus(`PASSCODE FAILURE: Missing D4 Trigger Word.`, true);
                    this.updateNotification('INITIAL'); 
                    return;
                }
                
                if (numbers.length > 3) {
                    // FIX: If more than 3 numbers, prioritize the first for D1, and the last two for D2 and D3.
                    if (numbers.length >= 3) { 
                        d1 = numbers[0]; 
                        d2 = numbers[numbers.length - 2];
                        d3 = numbers[numbers.length - 1];
                        this.logStatus(`OVERRIDE: Parsed ${numbers.length} digits. Forced D1=${d1}, D2=${d2}, D3=${d3}`);
                    } else {
                         // This case shouldn't realistically happen if length > 3, but safe guard.
                         this.logStatus(`PASSCODE FAILURE: Too many digits but somehow less than 3.`, true);
                         this.updateNotification('INITIAL'); 
                         return; 
                    }
                } else if (numbers.length === 3) {
                    // Standard case: D1, D2, D3 provided explicitly
                    [d1, d2, d3] = numbers;
                    this.logStatus("Parsed 3 digits (D1, D2, D3).", false);
                } else if (numbers.length === 2) {
                    // D1 is missing, so D1 defaults to 0 (meaning 10 letters)
                    d1 = 0;
                    [d2, d3] = numbers;
                    this.logStatus("Parsed 2 digits (D2, D3). D1 defaults to 0 (Length 10).", false);
                } else {
                    // Hard failure for 0 or 1 digits
                    this.logStatus(`PASSCODE FAILURE: Failed to parse required 2 or 3 digits. Found only ${numbers.length}.`, true);
                    this.updateNotification('INITIAL'); 
                    return; 
                }
                // --- END CRITICAL FAILURE CHECKS ---


                this.logStatus(`PASSCODE PARSED: D1=${d1}${d2}${d3}${d4}. (Length: ${d1 === 0 ? '10' : d1 + ' or ' + (d1 + 10)}), D2=${d2}, D3=${d3}, D4=${d4}`);

                if (typeof LARGE_DICTIONARY === 'undefined' || LARGE_DICTIONARY.length === 0) { 
                    this.logStatus("Dictionary (LARGE_DICTIONARY) not loaded. Resetting.", true); 
                    this.resetApp(true);
                    return; 
                }

                const matches = this.filterDictionary(d1, d2, d3, d4, LARGE_DICTIONARY);

                if (matches.length === 0) {
                    // SCENARIO 2: FILTERING FAILED (0 matches). 
                    this.logStatus("Code filtered to 0 matches. Displaying 'Update not available' and restarting listener.");
                    this.updateNotification('NO_MATCHES'); 
                    return; 
                }

                this.HISTORY = []; 
                this.HISTORY.push(matches);
                this.MATCHES = matches;

                this.logStatus(`Code: ${d1}${d2}${d3}${d4}. Filtered Matches: ${matches.length}`);
                
                this.checkMatchesAndProceed();
            },
            
            handleLetterInput(transcript) {
                if (this.MATCHES.length <= 1) {
                    this.logStatus("Ignoring letter input, solution already found.");
                    return; 
                }
                
                const trigger = "INTERESTING";
                const triggerIndex = transcript.indexOf(trigger);
                
                if (triggerIndex === -1) {
                    this.logStatus("No 'interesting' trigger. Ignoring input.");
                    return; 
                }
                
                const preTrigger = transcript.substring(0, triggerIndex).trim();
                // FIX: Corrected variable name from 'preWords' to 'preTrigger'
                const preWords = preTrigger.split(' ').filter(w => w.length > 0); 
                
                if (preWords.length === 0) {
                    this.logStatus("No word found before 'interesting'. Ignoring input.");
                    return; 
                }
                
                const spokenWord = preWords[preWords.length - 1];
                const magicLetter = spokenWord[0].toUpperCase();
                const pos = this.CURRENT_POSITION_INDEX - 1; 

                const filtered = this.MATCHES.filter(word => 
                    word.length > pos && word[pos] === magicLetter
                );

                if (filtered.length === 0) {
                    // Letter filter failed - Revert to previous list and keep listening
                    this.logStatus(`Filter failed: Letter '${magicLetter}' yielded 0 matches. Staying on current list.`);
                    this.updateNotification('WORD_LIST'); 
                    return; 
                }

                this.HISTORY.push(filtered);
                this.MATCHES = filtered;
                this.logStatus(`Filtered by letter '${magicLetter}' at position ${this.CURRENT_POSITION_INDEX}. ${filtered.length} matches remain.`);

                this.checkMatchesAndProceed();
            },

            // --- State and UI Update ---

            updateNotification(status) {
                const notifIcon = document.getElementById('notif-icon');
                const notifText = document.getElementById('notif-text');
                const currentSecond = document.getElementById('current-second');
                const widget = document.getElementById('transcript-widget');
                
                if (status === 'FINAL') {
                    // Final state - Permanent Stop
                    this.stopListening(); 
                    this.clearState(); // Clear session state on final success
                    notifIcon.innerHTML = this.ICON_CHAT_SVG; 
                    const finalWord = this.MATCHES[0];
                    notifText.innerHTML = `Sohan wants ${finalWord.toLowerCase()} to...`; 
                    currentSecond.textContent = '00';
                    
                } else if (status === 'WORD_LIST' && this.MATCHES.length > 0) {
                    // SUCCESS PATH: Display word list 
                    this.APP_STATE = 'AOD_LISTENING';
                    const displayWords = this.MATCHES.map(w => w.toLowerCase()).join(', '); 
                    
                    notifIcon.innerHTML = this.ICON_CHAT_SVG; 
                    notifText.innerHTML = `To buy: ${displayWords}`; 
                    currentSecond.textContent = this.CURRENT_POSITION_INDEX.toString().padStart(2, '0');
                    this.updateListeningUI(true); 
                    this.saveState(); 

                } else if (status === 'NO_MATCHES') {
                    // SCENARIO 2 PATH: Valid code, 0 matches. Keeps listening for a new code.
                    this.APP_STATE = 'AOD_LISTENING'; 
                    notifIcon.innerHTML = this.ICON_GEAR_SVG;
                    notifText.textContent = "Update not available"; 
                    currentSecond.textContent = '00';
                    
                    // Add debug message to transcript widget 
                    if (widget) {
                        widget.textContent += '\n\n>>> CODE FAILED (0 matches). Listening for new code...';
                        widget.scrollTop = widget.scrollHeight; 
                    }

                    this.updateListeningUI(true); 

                } else if (status === 'INITIAL') {
                    // DEFAULT PATH/SILENT RECOVERY: Displays default text.
                    notifIcon.innerHTML = this.ICON_GEAR_SVG;
                    notifText.textContent = "System Update Available"; 
                    currentSecond.textContent = '00';
                    this.clearState(); 
                    
                    if (!this.isListening) {
                        this.APP_STATE = 'AOD_LOCK';
                        this.updateListeningUI(false); 
                    } else {
                        this.APP_STATE = 'AOD_LISTENING'; 
                        this.updateListeningUI(true);
                    }
                }
            },

            checkMatchesAndProceed() {
                if (this.MATCHES.length === 1) {
                    // Final word found
                    this.APP_STATE = 'AOD_DISPLAY_FINAL';
                    this.updateNotification('FINAL'); 
                    
                } else if (this.MATCHES.length > 1) {
                    // Need more filtering
                    const bestIndex = this.getDisambiguationIndex(this.MATCHES);

                    if (bestIndex === 0) {
                        this.logStatus(`Ambiguous State: ${this.MATCHES.length} matches. Cannot find suitable disambiguation index.`);
                        this.CURRENT_POSITION_INDEX = 0; 
                    } else {
                        this.CURRENT_POSITION_INDEX = bestIndex;
                    }
                    
                    document.getElementById('current-second').textContent = this.CURRENT_POSITION_INDEX.toString().padStart(2, '0');
                    
                    this.updateNotification('WORD_LIST'); 
                    
                } else {
                    this.logStatus("Error state: Matches list is empty. Hard resetting.");
                    this.resetApp(true);
                }
            },
            
            resetApp(returnToLock = true) {
                if (this.isListening) {
                    try { if (this.recognizer) this.recognizer.abort(); } catch(e){}
                }
                
                this.MATCHES = [];
                this.HISTORY = [];
                this.CURRENT_POSITION_INDEX = 0;
                document.getElementById('current-second').textContent = '00';
                
                // Reset the transcript widget content
                document.getElementById('transcript-widget').textContent = "Ready. Double-tap blank area to hide/show."; 

                if (returnToLock) {
                    this.updateNotification('INITIAL');
                    this.logStatus("App reset to AOD_LOCK state.");
                    this.clearState();
                    
                    this.APP_STATE = 'AOD_LOCK';
                    this.updateListeningUI(false); 
                } else {
                    this.updateNotification('INITIAL'); 
                    this.APP_STATE = 'AOD_LISTENING'; 
                    this.logStatus("App state cleared, ready for new voice input.");
                }
            },
            
            logStatus(message, isError = false) {
                const prefix = isError ? "ERROR: " : "INFO: ";
                console.log(prefix + message); 
            },

            // --- Service Worker Registration (Loads sw.js) ---
            registerServiceWorker() {
                if ('serviceWorker' in navigator) {
                    window.addEventListener('load', () => {
                        // CRITICAL: We register the standard worker here
                        navigator.serviceWorker.register('./sw.js', { scope: './' }) 
                            .then(reg => {
                                this.logStatus('Service Worker (SW) registration successful.');
                            })
                            .catch(err => this.logStatus(`Service Worker registration failed: ${err.message}.`, true));
                    });
                }
            },

            // --- Initialization ---
            init() {
                if (typeof LARGE_DICTIONARY === 'undefined' || LARGE_DICTIONARY.length === 0) {
                    this.logStatus("WARNING: Dictionary (LARGE_DICTIONARY) not yet loaded.", true);
                    document.getElementById('notif-text').textContent = "WAITING FOR DICT...";
                } else {
                     this.logStatus(`App ready. Dictionary size: ${LARGE_DICTIONARY.length}. Tap clock to start.`);
                }
                
                this.initVoiceRecognition();
                this.updateTime();
                setInterval(() => this.updateTime(), 1000);   
                
                const clockContainer = document.getElementById('clock-container');
                const appElement = document.getElementById('app');
                
                // 1. VOICE INPUT HANDLERS
                
                // Robust Mobile Touch Handling for Single/Double Tap
                let lastTap = 0;
                const doubleTapThreshold = 300; // ms

                clockContainer.addEventListener('touchend', function(e) {
                    e.preventDefault(); 
                    const now = Date.now();
                    
                    // Check for double tap
                    if (now - lastTap < doubleTapThreshold) {
                        // Double Tap (Master Reset)
                        APP.handleDoubleTap(e);
                        lastTap = 0; // Reset last tap time after successful double tap
                    } else {
                        // Single Tap (Mic Restart - the core fix for resume/reopen)
                        APP.handleSingleTap(e); 
                    }
                    lastTap = now;
                });

                // Click fallback for desktop/non-touch environments
                clockContainer.addEventListener('click', (e) => {
                    // Only run click if it wasn't part of a recent touch event (to prevent double handling)
                    if (Date.now() - lastTap > doubleTapThreshold * 2) { 
                        APP.handleSingleTap(e);
                    }
                });
                
                // Double tap on app body (outside clock/player) to toggle transcript widget
                appElement.addEventListener('dblclick', (e) => this.toggleTranscriptWidget(e));
                
                // Attempt to load and resume state
                const resumed = this.loadState();

                if (!resumed) {
                    this.updateNotification('INITIAL');
                }
                
                // Start listening initially to ensure mic is active if permissions are granted.
                if (this.APP_STATE !== 'AOD_DISPLAY_FINAL') {
                    this.startListening();
                }

                this.registerServiceWorker(); // PWA registration is here
            }
        };

        window.onload = () => APP.init();
    </script>
</body>
</html>
