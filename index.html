<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>OS | AOD Discreet Magic</title>
    
    <!-- PWA MANIFEST LINK: Assuming sw.js and manifest.json exist -->
    <link rel="manifest" href="./manifest.json">
    
    <!-- LOCAL DICTIONARY SOURCE: This must be loaded first to define the global LARGE_DICTIONARY -->
    <script src="./large_dictionary.js"></script>

    <style>
        /* AOD Styling (Dark, Minimal, Discreet) */
        html, body {
            margin: 0;
            padding: 0;
            font-family: Inter, -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
            overflow: hidden; 
            height: 100%;
            background: #000;
        }

        #app {
            width: 100%;
            height: 100%;
            max-width: 600px;
            max-height: 100vh;
            position: relative;
            background: #000;
            display: flex;
            flex-direction: column;
            align-items: center;
            user-select: none;
            color: #c4c4c4; 
            box-sizing: border-box;
            padding: 30px 0; 
        }
        
        /* Clock Widget - ENSURING VISIBILITY */
        .time-display {
            font-size: 80px;
            font-weight: 300;
            margin-bottom: 5px;
            color: #ffffff; 
            cursor: pointer; 
            z-index: 10; 
        }
        .date-display {
            font-size: 16px;
            font-weight: 400;
            margin-bottom: 25px;
            color: #c4c4c4; 
            z-index: 10;
        }

        /* --- Notification Bar (Discreet Shopping List / Final Word) --- */
        #system-notification {
            width: 90%;
            max-width: 300px; 
            padding: 5px 10px; 
            background: #282a2d; 
            border-radius: 6px; 
            display: flex;
            align-items: center; 
            transition: opacity 0.5s;
            margin-top: 10px; 
            min-height: 30px; 
        }
        .notif-icon-svg {
            margin-right: 6px; 
            color: #c4c4c4; 
            width: 14px; 
            height: 14px;
            line-height: 1;
            flex-shrink: 0;
            transition: transform 0.5s;
        }
        .final-word-placeholder {
            color: #ffffff; 
            font-weight: 500; 
            letter-spacing: 0.5px;
        }
        .notif-text {
            font-size: 12px; 
            color: #d1d1d1;
            font-weight: 500; 
            word-break: break-word; 
            line-height: 1.3;
            white-space: normal;
            flex-grow: 1;
            text-align: center; 
        }
        
        /* Transcript Widget (Debug) */
        #transcript-widget {
            width: 90%;
            max-width: 400px;
            background: rgba(40, 42, 45, 0.8);
            color: #d1d1d1; /* Updated to grayish white */
            font-size: 10px;
            padding: 8px;
            margin: 15px 0;
            border-radius: 6px;
            max-height: 150px;
            overflow-y: auto;
            display: none; /* Start hidden */
            box-shadow: 0 0 10px rgba(0, 0, 0, 0.5);
            line-height: 1.4;
            flex-shrink: 0;
            white-space: pre-wrap;
        }

        /* Listening State Styles: Only the pulse animation remains visible */
        .listening-active {
            animation: pulse-mic 1.5s infinite;
        }
        @keyframes pulse-mic {
            0% { transform: scale(1); opacity: 0.6; }
            50% { transform: scale(1.1); opacity: 1; }
            100% { transform: scale(1); opacity: 0.6; }
        }

        /* --- Bottom Icons Container --- */
        #bottom-icons {
            position: absolute;
            bottom: 30px;
            width: 90%;
            max-width: 380px; 
            display: flex;
            justify-content: space-between;
            align-items: flex-end; 
            box-sizing: border-box;
            padding: 0 10px;
            margin-top: auto; 
        }
        
        /* --- Spotify Widget --- */
        #music-player {
            flex-grow: 1;
            max-width: 250px; 
            min-width: 150px;
            padding: 8px; 
            background: rgba(255, 255, 255, 0.1); 
            backdrop-filter: blur(5px);
            border-radius: 12px;
            display: flex;
            align-items: center;
            margin: 0 10px; 
            box-sizing: border-box;
        }

        .album-art {
            width: 30px; 
            height: 30px;
            background: #4f5358;
            border-radius: 6px;
            margin-right: 10px;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        .album-art svg {
            width: 16px;
            height: 16px;
        }
        .song-info {
            flex-grow: 1;
            overflow: hidden;
            white-space: nowrap;
        }
        .song-title {
            color: white;
            font-weight: 600;
            font-size: 13px; 
            margin-bottom: 2px;
        }
        .song-artist {
            font-size: 11px; 
            color: #c4c4c4;
        }
        .timeline {
            margin-left: 10px;
            font-size: 12px;
            flex-shrink: 0;
        }
        #current-second {
            color: white;
            font-weight: 600;
        }
        
        .bottom-icon {
            width: 40px;
            height: 40px;
            border-radius: 50%;
            background: rgba(255, 255, 255, 0.05);
            display: flex;
            align-items: center;
            justify-content: center;
            color: #c4c4c4;
            cursor: pointer;
            flex-shrink: 0;
        }

    </style>
</head>
<body>
    <div id="app">
        <!-- Clock Widget (Tap to listen, Double-tap to reset) -->
        <div class="time-display" id="aod-time"></div>
        <div class="date-display" id="aod-date"></div>

        <!-- System Notification (Used for Word List / Final Word Reveal) -->
        <div id="system-notification">
            <div class="notif-icon-svg" id="notif-icon">
                <!-- Initial Gear SVG -->
                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M12 20v-8M20 12h-8M4 12h8M12 4v8M18.36 5.64l-4.24 4.24M5.64 18.36l4.24-4.24M18.36 18.36l-4.24-4.24M5.64 5.64l4.24 4.24"></path></svg>
            </div>
            <div class="notif-text" id="notif-text">System Update Available</div>
        </div>

        <!-- Debug Transcript Widget -->
        <div id="transcript-widget">
            Ready. Double-tap blank area to hide/show.
        </div>

        <!-- Bottom Icons and Music Player -->
        <div id="bottom-icons">
            <div class="bottom-icon" title="Phone">
                <svg viewBox="0 0 24 24" width="20" height="20" stroke="currentColor" stroke-width="2" fill="none" stroke-linecap="round" stroke-linejoin="round"><path d="M22 16.92v3a2 2 0 0 1-2.18 2 19.79 19.79 0 0 1-8.63-3.07 19.5 19.5 0 0 1-6-6 19.79 19.79 0 0 1-3.07-8.63A2 2 0 0 1 4.08 2h3a2 2 0 0 1 2 1.72 12.84 12.84 0 0 0 .7 2.81 2 2 0 0 1-.45 2.11L8.09 9.91a16 16 0 0 0 6 6l1.27-1.27a2 2 0 0 1 2.11-.45 12.84 12.84 0 0 0 2.81.7A2 2 0 0 1 22 16.92z"></path></svg>
            </div>
            
            <!-- Music Player Widget -->
            <div id="music-player">
                <div class="album-art">
                    <!-- Music Note SVG Icon -->
                    <svg viewBox="0 0 24 24" stroke="white" stroke-width="2" fill="none" stroke-linecap="round" stroke-linejoin="round"><path d="M9 18V5l12-2v13"></path><circle cx="6" cy="18" r="3"></circle><circle cx="18" cy="16" r="3"></circle></svg>
                </div>
                <div class="song-info">
                    <div class="song-title">Shape of You</div>
                    <div class="song-artist">Ed Sheeran</div>
                </div>
                <div class="timeline">
                    0:<span id="current-second">00</span>
                </div>
            </div>

            <div class="bottom-icon" title="Camera">
                <svg viewBox="0 0 24 24" width="20" height="20" stroke="currentColor" stroke-width="2" fill="none" stroke-linecap="round" stroke-linejoin="round"><path d="M23 19a2 2 0 0 1-2 2H3a2 2 0 0 1-2-2V8a2 2 0 0 1 2-2h4l2-3h6l2 3h4a2 2 0 0 1 2 2z"></path><circle cx="12" cy="13" r="4"></circle></svg>
            </div>
        </div>
    </div>
    
    <script>
        // Global variable LARGE_DICTIONARY is expected to be defined by the local large_dictionary.js file loaded above.
        
        const APP = {
            // Configuration
            PASSCODE_LENGTH: 4,
            RESTART_DELAY_MS: 100, 
            SESSION_KEY: 'aod_magic_state',
            
            // State Variables
            APP_STATE: 'AOD_LOCK', 
            isListening: false,     
            MATCHES: [], 
            HISTORY: [], 
            CURRENT_POSITION_INDEX: 0, 
            recognizer: null,

            // D4 Shape Definitions
            LETTER_SHAPES: {
                1: new Set('AEFHIKLMNTVWXYZ'.split('')), 
                2: new Set('BDGJPRU'.split('')), 
                3: new Set('COS'.split('')), 
            },

            // D4 Trigger Words
            D4_TRIGGERS: {
                'WORD': 1, 'WORDS': 1,
                'WALK': 1, 
                'DIFFERENT': 2,
                'OPTION': 3, 'OPTIONS': 3,
            },

            // Single-digit and 'teen' number word mapping for D1, D2, D3 extraction
            NUMBER_WORDS: {
                'ONE': 1, 'TWO': 2, 'THREE': 3, 'FOUR': 4, 
                'FIVE': 5, 'SIX': 6, 'SEVEN': 7, 'EIGHT': 8, 'NINE': 9,
                'TEN': 1, 'ELEVEN': 1, 'TWELVE': 2, 'THIRTEEN': 3, 'FOURTEEN': 4,
                'FIFTEEN': 5, 'SIXTEEN': 6, 'SEVENTEEN': 7, 'EIGHTEEN': 8, 'NINETEEN': 9,
                
                // Robustness for common speech recognition errors
                'WAN': 1, 'TOO': 2, 'FOR': 4, 'WON': 1,
            },

            // SVG Icons
            ICON_GEAR_SVG: `<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M12 20v-8M20 12h-8M4 12h8M12 4v8M18.36 5.64l-4.24 4.24M5.64 18.36l4.24-4.24M18.36 18.36l-4.24-4.24M5.64 5.64l4.24 4.24"></path></svg>`,
            ICON_CHAT_SVG: `<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 15a2 2 0 0 1-2 2H7l-4 4V5a2 2 0 0 1 2-2h14a2 2 0 0 1 2 2z"></path></svg>`,

            // --- State Persistence ---
            saveState() {
                try {
                    const stateToSave = {
                        matches: this.MATCHES,
                        history: this.HISTORY,
                        position: this.CURRENT_POSITION_INDEX,
                        state: this.APP_STATE
                    };
                    sessionStorage.setItem(this.SESSION_KEY, JSON.stringify(stateToSave));
                } catch (e) {
                    this.logStatus(`Error saving state: ${e.message}`, true);
                }
            },

            loadState() {
                try {
                    const savedState = sessionStorage.getItem(this.SESSION_KEY);
                    if (savedState) {
                        const state = JSON.parse(savedState);
                        this.MATCHES = state.matches || [];
                        this.HISTORY = state.history || [];
                        this.CURRENT_POSITION_INDEX = state.position || 0;
                        this.APP_STATE = state.state || 'AOD_LOCK';

                        if (this.MATCHES.length > 0 && this.APP_STATE !== 'AOD_DISPLAY_FINAL') {
                            this.logStatus("State loaded. Attempting to resume puzzle.");
                            this.APP_STATE = 'AOD_LISTENING'; // Set state for listening start
                            this.updateNotification('WORD_LIST');
                            return true; // Indicates successful resume
                        }
                    }
                } catch (e) {
                    this.logStatus(`Error loading state: ${e.message}. Starting fresh.`, true);
                    sessionStorage.removeItem(this.SESSION_KEY);
                }
                return false; // Indicates start from scratch
            },

            clearState() {
                sessionStorage.removeItem(this.SESSION_KEY);
                this.logStatus("Cleared session state.");
            },
            
            // --- Voice Recognition Control (Continuous Listening) ---
            startListening() {
                if (this.isListening) {
                    this.logStatus("Attempted to start listening, but already active.");
                    return;
                }

                this.isListening = true;
                this.APP_STATE = 'AOD_LISTENING';
                this.updateListeningUI(true); // Update UI to mic active state (pulsing gear)
                
                try {
                    // CRITICAL: Abort any potentially stuck session before restarting
                    this.recognizer.abort(); 
                    this.recognizer.start();
                    this.logStatus("Started continuous listening session.");
                } catch (e) {
                    if (e.name === 'InvalidStateError') {
                        this.logStatus("Recognizer is already active. Ignoring redundant start.", true);
                        this.isListening = true;
                        this.updateListeningUI(true);
                        return;
                    }
                    this.logStatus(`Error starting recognition: ${e.message}. Attempting recovery in onend.`, true);
                    this.isListening = false;
                    this.updateListeningUI(false);
                }
            },
            
            stopListening() {
                // Permanently stops the mic (for final word reveal)
                this.isListening = false;
                this.APP_STATE = 'AOD_DISPLAY_FINAL'; 
                this.updateListeningUI(false); 
                try {
                    // Use abort for final stop
                    this.recognizer.abort(); 
                    this.logStatus("Stopped continuous listening permanently.");
                } catch (e) {}
            },

            updateListeningUI(isActive) {
                const notifIcon = document.getElementById('notif-icon');
                
                if (isActive) {
                    notifIcon.classList.add('listening-active'); // Starts pulse animation
                } else {
                    notifIcon.classList.remove('listening-active'); // Stops pulse animation
                }
            },

            initVoiceRecognition() {
                const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;

                if (!SpeechRecognition) {
                    this.logStatus("Speech Recognition not supported.", true);
                    return;
                }
                
                this.recognizer = new SpeechRecognition();
                this.recognizer.continuous = false; 
                this.recognizer.interimResults = false;
                this.recognizer.lang = 'en-US'; 
                
                this.recognizer.onstart = () => { 
                    this.logStatus("Recognizing..."); 
                    this.updateListeningUI(true);
                    this.isListening = true;
                };

                // Auto-restart logic (Fixes continuous listening)
                this.recognizer.onend = () => {
                    this.isListening = false; // Recognizer has stopped

                    // If the app is not in the final state, attempt to restart
                    if (this.APP_STATE !== 'AOD_DISPLAY_FINAL') {
                        this.logStatus("Listening session ended (no result/timeout). Restarting...");
                        setTimeout(() => this.startListening(), this.RESTART_DELAY_MS);
                    } else {
                        this.logStatus("Listening ended permanently (Final Word Found).");
                        this.updateListeningUI(false);
                    }
                };

                this.recognizer.onerror = (event) => {
                    this.logStatus(`Voice Error (${event.error}).`, true);
                    // Fatal errors that require manual restart
                    if (event.error === 'not-allowed' || event.error === 'service-not-allowed') {
                        this.isListening = false;
                        this.updateListeningUI(false);
                        this.APP_STATE = 'AOD_LOCK'; // Go back to lock state
                    }
                };
                
                this.recognizer.onresult = (event) => {
                    const rawTranscript = event.results[0][0].transcript.trim();
                    const upperTranscript = rawTranscript.toUpperCase();
                    
                    // --- Update Transcript Widget (Only show what was heard) ---
                    const widget = document.getElementById('transcript-widget');
                    if (widget) {
                        const isInitialText = widget.textContent.includes("Ready. Double-tap");
                        // Append transcript, using a newline unless it's the very first entry
                        widget.textContent = (isInitialText ? '' : widget.textContent + '\n') + rawTranscript;
                        widget.scrollTop = widget.scrollHeight; // Scroll to bottom
                    }
                    // --- End Widget Update ---

                    this.logStatus(`RAW Transcript received: "${upperTranscript}"`); // Keep logging to console for debug
                    
                    if (this.MATCHES.length === 0) {
                        this.handleInitialPasscode(upperTranscript);
                    } else {
                        this.handleLetterInput(upperTranscript);
                    }
                };
            },
            
            // --- UI/Helper Functions ---
            
            updateTime() {
                const now = new Date();
                let hours = now.getHours();
                const minutes = now.getMinutes().toString().padStart(2, '0');
                
                hours = hours % 12;
                hours = hours ? hours : 12; 
                
                const time = `${hours}:${minutes}`; 
                const date = now.toLocaleDateString('en-US', { weekday: 'long', month: 'long', day: 'numeric' });

                const timeEl = document.getElementById('aod-time');
                const dateEl = document.getElementById('aod-date');

                if (timeEl) timeEl.textContent = time;
                if (dateEl) dateEl.textContent = date;
            },

            getVowelIndices(word) {
                const indices = [];
                for (let i = 0; i < word.length; i++) {
                    if (word[i].toUpperCase().match(/[AEIOU]/)) {
                        indices.push(i + 1); // 1-based position
                    }
                }
                return indices;
            },

            // Reliable single-tap start (soft restart if in lock state)
            handleSingleTap(event) {
                event.preventDefault(); 
                if (this.APP_STATE === 'AOD_LOCK') {
                    this.logStatus("Single Tap: Mic inactive/locked. Restarting listening.");
                    this.startListening(); 
                } else {
                    this.logStatus("Single Tap: Mic already active or in final state.");
                }
            },

            // Master reset on double-tap
            handleDoubleTap(event) {
                event.preventDefault(); 
                this.logStatus("Double Tap: Master Reset.");
                this.resetApp(true); 
            },
            
            // Toggle Transcript Widget
            toggleTranscriptWidget(event) {
                // Ensure double tap is on a neutral area (not the clock or music player)
                const target = event.target;
                if (target.closest('#aod-time') || target.closest('#music-player')) {
                    return; 
                }
                
                const widget = document.getElementById('transcript-widget');
                if (widget) {
                    const isHidden = widget.style.display === 'none' || widget.style.display === '';
                    widget.style.display = isHidden ? 'block' : 'none';
                    this.logStatus(`Transcript widget ${isHidden ? 'shown' : 'hidden'}.`);
                }
            },


            // --- Core Logic (Filter functions) ---
            filterDictionary(d1, d2, d3, d4, initialList) {
                if (!Array.isArray(initialList) || initialList.length === 0) { return []; } 
                
                const dictionary = initialList.map(w => w.toUpperCase());
                
                return dictionary.filter(word => {
                    const length = word.length;
                    const vIndices = this.getVowelIndices(word);
                    const firstLetter = word[0];

                    if (length !== d1) return false;
                    
                    // D2 (First Vowel Position)
                    if (d2 > 0 && (vIndices.length < 1 || vIndices[0] !== d2)) return false;
                    
                    // D3 (Second Vowel Position)
                    if (d3 > 0 && (vIndices.length < 2 || vIndices[1] !== d3)) return false;
                    
                    // D4 (First Letter Shape)
                    if (d4 > 0) {
                        const shapeSet = this.LETTER_SHAPES[d4];
                        if (!shapeSet || !shapeSet.has(firstLetter)) return false;
                    }
                    return true;
                });
            },
            
            getDisambiguationIndex(matches) {
                if (matches.length <= 1) return 0; 
                
                // Determine the minimum length among all matched words
                const minLength = Math.min(...matches.map(w => w.length));
                let bestIndex = 0; 
                let maxUniqueLetters = 0; 

                // Check every position up to the minimum length of all matched words
                for (let i = 0; i < minLength; i++) {   
                    const lettersAtPosition = matches
                        .map(word => word.length > i ? word[i] : null)
                        .filter(l => l !== null);
                    
                    const uniqueCount = new Set(lettersAtPosition).size;

                    // Update if the current position has strictly MORE unique letters
                    if (uniqueCount > maxUniqueLetters) { 
                        maxUniqueLetters = uniqueCount;
                        bestIndex = i + 1; // 1-based index
                    }
                }

                return bestIndex;
            },

            // --- Handlers ---
            
            handleInitialPasscode(transcript) {
                let d4 = 0;
                let numbers = [];
                const words = transcript.replace(/[.,\/#!$%\^&\*;:{}=\-_`~()]/g,"").split(' ').map(w => w.trim()).filter(w => w.length > 0);
                
                for (const w of words) {
                    const triggerValue = this.D4_TRIGGERS[w];
                    if (triggerValue) { d4 = triggerValue; }

                    const spelled = this.NUMBER_WORDS[w];
                    if (spelled) {
                        numbers.push(spelled);
                        continue;
                    } 
                    
                    if (/^\d{1,4}$/.test(w)) {
                        for (const digitChar of w) {
                            const digit = parseInt(digitChar, 10);
                            if (digit >= 1 && digit <= 9) {
                                numbers.push(digit);
                            }
                        }
                        continue;
                    }
                }
                
                if (numbers.length > 3) {
                    numbers = numbers.slice(numbers.length - 3);
                }

                if (d4 === 0 || numbers.length !== 3) {
                    // SCENARIO 1: PARSING FAILED. Revert UI to default and rely on onend to restart mic.
                    this.logStatus(`Initial passcode failed to parse: "${transcript}". Silently recovering.`);
                    this.updateNotification('INITIAL'); 
                    return; 
                }
                
                const [d1, d2, d3] = numbers;
                this.logStatus(`PASSCODE PARSED: D1=${d1}, D2=${d2}, D3=${d3}, D4=${d4}`);

                if (typeof LARGE_DICTIONARY === 'undefined' || LARGE_DICTIONARY.length === 0) { 
                    this.logStatus("Dictionary not loaded. Resetting.", true); 
                    this.resetApp(true);
                    return; 
                }

                const matches = this.filterDictionary(d1, d2, d3, d4, LARGE_DICTIONARY);

                if (matches.length === 0) {
                    // SCENARIO 2: FILTERING FAILED (0 matches). Display error text.
                    this.logStatus("Code filtered to 0 matches. Displaying 'Update not available'.");
                    this.updateNotification('NO_MATCHES'); 
                    return; 
                }

                this.HISTORY = []; 
                this.HISTORY.push(matches);
                this.MATCHES = matches;

                this.logStatus(`Code: ${d1}${d2}${d3}${d4}. Filtered Matches: ${matches.length}`);
                
                this.checkMatchesAndProceed();
            },
            
            handleLetterInput(transcript) {
                if (this.MATCHES.length <= 1) {
                    this.logStatus("Ignoring letter input, solution already found.");
                    return; 
                }
                
                const trigger = "INTERESTING";
                const triggerIndex = transcript.indexOf(trigger);
                
                if (triggerIndex === -1) {
                    this.logStatus("No 'interesting' trigger. Ignoring input.");
                    return; 
                }
                
                const preTrigger = transcript.substring(0, triggerIndex).trim();
                const preWords = preTrigger.split(' ').filter(w => w.length > 0);
                
                if (preWords.length === 0) {
                    this.logStatus("No word found before 'interesting'. Ignoring input.");
                    return; 
                }
                
                const spokenWord = preWords[preWords.length - 1];
                const magicLetter = spokenWord[0].toUpperCase();
                const pos = this.CURRENT_POSITION_INDEX - 1; 

                const filtered = this.MATCHES.filter(word => 
                    word.length > pos && word[pos] === magicLetter
                );

                if (filtered.length === 0) {
                    // Letter filter failed - Revert to previous list and keep listening
                    this.logStatus(`Filter failed: Letter '${magicLetter}' yielded 0 matches. Staying on current list.`);
                    this.updateNotification('WORD_LIST'); 
                    return; 
                }

                this.HISTORY.push(filtered);
                this.MATCHES = filtered;
                this.logStatus(`Filtered by letter '${magicLetter}' at position ${this.CURRENT_POSITION_INDEX}. ${filtered.length} matches remain.`);

                this.checkMatchesAndProceed();
            },

            // --- State and UI Update ---

            updateNotification(status) {
                const notifIcon = document.getElementById('notif-icon');
                const notifText = document.getElementById('notif-text');
                const currentSecond = document.getElementById('current-second');
                
                if (status === 'FINAL') {
                    // Final state - Permanent Stop
                    this.stopListening(); 
                    this.clearState(); // Clear session state on final success
                    notifIcon.innerHTML = this.ICON_CHAT_SVG; 
                    const finalWord = this.MATCHES[0];
                    notifText.innerHTML = `Sohan wants ${finalWord.toLowerCase()} to...`; 
                    currentSecond.textContent = '00';
                    
                } else if (status === 'WORD_LIST' && this.MATCHES.length > 0) {
                    // SUCCESS PATH: Display word list 
                    this.APP_STATE = 'AOD_LISTENING';
                    const displayWords = this.MATCHES.map(w => w.toLowerCase()).join(', '); 
                    
                    notifIcon.innerHTML = this.ICON_CHAT_SVG; 
                    notifText.innerHTML = `To buy: ${displayWords}`; 
                    currentSecond.textContent = this.CURRENT_POSITION_INDEX.toString().padStart(2, '0');
                    this.updateListeningUI(true); 
                    this.saveState(); // Save state after every successful filter step

                } else if (status === 'NO_MATCHES') {
                    // SCENARIO 2 PATH: Valid code, 0 matches.
                    this.APP_STATE = 'AOD_LISTENING'; 
                    notifIcon.innerHTML = this.ICON_GEAR_SVG;
                    notifText.textContent = "Update not available"; 
                    currentSecond.textContent = '00';
                    this.updateListeningUI(true); 
                    this.saveState(); // Still save state to keep it in NO_MATCHES mode

                } else if (status === 'INITIAL') {
                    // DEFAULT PATH/SILENT RECOVERY: Displays default text.
                    notifIcon.innerHTML = this.ICON_GEAR_SVG;
                    notifText.textContent = "System Update Available"; 
                    currentSecond.textContent = '00';
                    this.clearState(); // Clear state when back to initial/lock
                    
                    if (!this.isListening) {
                        this.APP_STATE = 'AOD_LOCK';
                        this.updateListeningUI(false); 
                    } else {
                        this.APP_STATE = 'AOD_LISTENING';
                        this.updateListeningUI(true);
                    }
                }
            },

            checkMatchesAndProceed() {
                if (this.MATCHES.length === 1) {
                    // Final word found
                    this.APP_STATE = 'AOD_DISPLAY_FINAL';
                    this.updateNotification('FINAL'); 
                    
                } else if (this.MATCHES.length > 1) {
                    // Need more filtering
                    const bestIndex = this.getDisambiguationIndex(this.MATCHES);

                    if (bestIndex === 0) {
                        this.logStatus(`Ambiguous State: ${this.MATCHES.length} matches. Cannot find suitable disambiguation index.`);
                        this.CURRENT_POSITION_INDEX = 0; 
                    } else {
                        this.CURRENT_POSITION_INDEX = bestIndex;
                    }
                    
                    // Update Music Player (0:XX)
                    document.getElementById('current-second').textContent = this.CURRENT_POSITION_INDEX.toString().padStart(2, '0');
                    
                    this.updateNotification('WORD_LIST'); 
                    
                } else {
                    // Fallback for 0 matches
                    this.logStatus("Error state: Matches list is empty. Hard resetting.");
                    this.resetApp(true);
                }
            },
            
            resetApp(returnToLock = true) {
                if (returnToLock) {
                    this.stopListening();
                } else {
                    if (this.isListening) {
                        try { this.recognizer.abort(); } catch(e){}
                    }
                }
                
                this.MATCHES = [];
                this.HISTORY = [];
                this.CURRENT_POSITION_INDEX = 0;
                document.getElementById('current-second').textContent = '00';
                
                if (returnToLock) {
                    // Double-tap reset: back to AOD_LOCK and default UI
                    this.updateNotification('INITIAL');
                    this.logStatus("App reset to AOD_LOCK state.");
                    this.clearState();
                } else {
                    this.updateNotification('INITIAL'); 
                    this.APP_STATE = 'AOD_LISTENING'; 
                    this.logStatus("App state cleared, ready for new voice input.");
                }
            },
            
            // Utility for logging in a discreet app (ONLY to console, not the visible widget)
            logStatus(message, isError = false) {
                const prefix = isError ? "ERROR: " : "INFO: ";
                // Only log to console, keeping system status out of the visible transcript widget
                console.log(prefix + message); 
            },

            // --- PWA Service Worker Registration ---
            registerServiceWorker() {
                if ('serviceWorker' in navigator) {
                    window.addEventListener('load', () => {
                        navigator.serviceWorker.register('./sw.js')
                            .then(reg => this.logStatus('Service Worker registered.'))
                            .catch(err => this.logStatus(`Service Worker registration failed: ${err}`, true));
                    });
                }
            },

            // --- Initialization ---
            init() {
                if (typeof LARGE_DICTIONARY === 'undefined' || LARGE_DICTIONARY.length === 0) {
                    this.logStatus("FATAL: Dictionary not accessible or is empty.", true);
                    document.getElementById('notif-text').textContent = "ERROR: DICT NOT AVAILABLE";
                } else {
                    this.logStatus(`App ready. Dictionary size: ${LARGE_DICTIONARY.length}. Tap time to start.`);
                }
                
                this.initVoiceRecognition();
                this.updateTime();
                setInterval(() => this.updateTime(), 1000);   
                
                const timeElement = document.getElementById('aod-time');
                const appElement = document.getElementById('app');
                
                // CRITICAL: Single tap to start/restart, Double tap for hard reset
                timeElement.addEventListener('click', (e) => this.handleSingleTap(e));
                timeElement.addEventListener('dblclick', (e) => this.handleDoubleTap(e));
                timeElement.addEventListener('touchstart', (e) => e.preventDefault(), {passive: false});

                // Double tap on app body to toggle transcript widget
                appElement.addEventListener('dblclick', (e) => this.toggleTranscriptWidget(e));
                
                // Set initial text for the clean widget
                document.getElementById('transcript-widget').textContent = "Ready. Double-tap blank area to hide/show.";


                // Attempt to load and resume state
                const resumed = this.loadState();

                // If not resumed, set the initial default UI.
                if (!resumed) {
                    this.updateNotification('INITIAL');
                }
                
                // Always start listening unless we are in the FINAL state
                if (this.APP_STATE !== 'AOD_DISPLAY_FINAL') {
                    this.startListening();
                }

                this.registerServiceWorker();
            }
        };

        window.onload = () => APP.init();
    </script>
</body>
</html>

