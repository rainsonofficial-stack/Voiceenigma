<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>OS | AOD Discreet Magic</title>
    
    <!-- PWA MANIFEST LINK -->
    <link rel="manifest" href="./manifest.json">
    
    <!-- LOCAL DICTIONARY SOURCE: This must be loaded first to define the global LARGE_DICTIONARY -->
    <script src="./large_dictionary.js"></script>

    <style>
        /* AOD Styling (Dark, Minimal, Discreet) */
        html, body {
            margin: 0;
            padding: 0;
            font-family: Inter, -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
            overflow: hidden; 
            height: 100%;
            background: #000;
        }

        #app {
            width: 100%;
            height: 100%;
            max-width: 600px;
            max-height: 100vh;
            position: relative;
            background: #000;
            display: flex;
            flex-direction: column;
            align-items: center;
            user-select: none;
            color: #c4c4c4; 
            box-sizing: border-box;
            padding: 30px 0; 
        }
        
        /* Clock Widget */
        .time-display {
            font-size: 80px;
            font-weight: 300;
            margin-bottom: 5px;
            color: white; 
            cursor: pointer; 
        }
        .date-display {
            font-size: 16px;
            font-weight: 400;
            margin-bottom: 25px;
            color: #c4c4c4; 
        }

        /* --- Notification Bar (Discreet Shopping List / Final Word) --- */
        #system-notification {
            width: 90%;
            max-width: 300px; 
            padding: 8px 12px; 
            background: #282a2d; 
            border-radius: 8px; 
            display: flex;
            align-items: center;
            transition: opacity 0.5s;
            margin-top: 10px; 
            min-height: 35px; /* Ensure space for transcript */
        }
        .notif-icon-svg {
            margin-right: 8px;
            color: #c4c4c4; 
            width: 16px;
            height: 16px;
            line-height: 1;
            flex-shrink: 0;
            transition: transform 0.5s;
        }
        .notif-text {
            font-size: 13px;
            color: #d1d1d1;
            font-weight: 500;
            word-break: break-word; 
            line-height: 1.3;
        }
        .final-word-placeholder {
            color: #ffffff; 
            font-weight: 700;
            letter-spacing: 1px;
        }
        
        /* New Listening State Styles */
        .listening-active {
            animation: pulse-mic 1.5s infinite;
        }
        @keyframes pulse-mic {
            0% { transform: scale(1); opacity: 0.6; }
            50% { transform: scale(1.1); opacity: 1; }
            100% { transform: scale(1); opacity: 0.6; }
        }

        /* --- Bottom Icons Container --- */
        #bottom-icons {
            position: absolute;
            bottom: 30px;
            width: 90%;
            max-width: 380px; 
            display: flex;
            justify-content: space-between;
            align-items: flex-end; 
            box-sizing: border-box;
            padding: 0 10px;
            margin-top: auto; 
        }
        
        /* --- Spotify Widget --- */
        #music-player {
            flex-grow: 1;
            max-width: 250px; 
            min-width: 150px;
            padding: 8px; 
            background: rgba(255, 255, 255, 0.1); 
            backdrop-filter: blur(5px);
            border-radius: 12px;
            display: flex;
            align-items: center;
            margin: 0 10px; 
            box-sizing: border-box;
        }

        .album-art {
            width: 30px; 
            height: 30px;
            background: #4f5358;
            border-radius: 6px;
            margin-right: 10px;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        .album-art svg {
            width: 16px;
            height: 16px;
        }
        .song-info {
            flex-grow: 1;
            overflow: hidden;
            white-space: nowrap;
        }
        .song-title {
            color: white;
            font-weight: 600;
            font-size: 13px; 
            margin-bottom: 2px;
        }
        .song-artist {
            font-size: 11px; 
            color: #c4c4c4;
        }
        .timeline {
            margin-left: 10px;
            font-size: 12px;
            flex-shrink: 0;
        }
        #current-second {
            color: white;
            font-weight: 600;
        }
        
        .bottom-icon {
            width: 40px;
            height: 40px;
            border-radius: 50%;
            background: rgba(255, 255, 255, 0.05);
            display: flex;
            align-items: center;
            justify-content: center;
            color: #c4c4c4;
            cursor: pointer;
            flex-shrink: 0;
        }

    </style>
</head>
<body>
    <div id="app">
        <!-- Clock Widget (Double tap here to trigger voice input) -->
        <div class="time-display" id="aod-time"></div>
        <div class="date-display" id="aod-date"></div>

        <!-- System Notification (Used for Word List / Final Word Reveal) -->
        <div id="system-notification">
            <div class="notif-icon-svg" id="notif-icon">
                <!-- Initial Gear SVG -->
                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M12 20v-8M20 12h-8M4 12h8M12 4v8M18.36 5.64l-4.24 4.24M5.64 18.36l4.24-4.24M18.36 18.36l-4.24-4.24M5.64 5.64l4.24 4.24"></path></svg>
            </div>
            <div class="notif-text" id="notif-text">System Update Available</div>
        </div>

        <!-- Bottom Icons and Music Player -->
        <div id="bottom-icons">
            <div class="bottom-icon" title="Phone">
                <svg viewBox="0 0 24 24" width="20" height="20" stroke="currentColor" stroke-width="2" fill="none" stroke-linecap="round" stroke-linejoin="round"><path d="M22 16.92v3a2 2 0 0 1-2.18 2 19.79 19.79 0 0 1-8.63-3.07 19.5 19.5 0 0 1-6-6 19.79 19.79 0 0 1-3.07-8.63A2 2 0 0 1 4.08 2h3a2 2 0 0 1 2 1.72 12.84 12.84 0 0 0 .7 2.81 2 2 0 0 1-.45 2.11L8.09 9.91a16 16 0 0 0 6 6l1.27-1.27a2 2 0 0 1 2.11-.45 12.84 12.84 0 0 0 2.81.7A2 2 0 0 1 22 16.92z"></path></svg>
            </div>
            
            <!-- Music Player Widget -->
            <div id="music-player">
                <div class="album-art">
                    <!-- Music Note SVG Icon -->
                    <svg viewBox="0 0 24 24" stroke="white" stroke-width="2" fill="none" stroke-linecap="round" stroke-linejoin="round"><path d="M9 18V5l12-2v13"></path><circle cx="6" cy="18" r="3"></circle><circle cx="18" cy="16" r="3"></circle></svg>
                </div>
                <div class="song-info">
                    <div class="song-title">Shape of You</div>
                    <div class="song-artist">Ed Sheeran</div>
                </div>
                <div class="timeline">
                    0:<span id="current-second">00</span>
                </div>
            </div>

            <div class="bottom-icon" title="Camera">
                <svg viewBox="0 0 24 24" width="20" height="20" stroke="currentColor" stroke-width="2" fill="none" stroke-linecap="round" stroke-linejoin="round"><path d="M23 19a2 2 0 0 1-2 2H3a2 2 0 0 1-2-2V8a2 2 0 0 1 2-2h4l2-3h6l2 3h4a2 2 0 0 1 2 2z"></path><circle cx="12" cy="13" r="4"></circle></svg>
            </div>
        </div>
    </div>
    
    <script>
        // Global variable LARGE_DICTIONARY is expected to be defined by the local large_dictionary.js file loaded above.
        
        const APP = {
            // Configuration
            PASSCODE_LENGTH: 4,
            DOUBLE_TAP_THRESHOLD: 300, 
            LAST_TAP_TIME: 0,
            RESTART_DELAY_MS: 50, 
            TRANSCRIPT_DISPLAY_DURATION: 2000, // 2 seconds to show failed transcript
            
            // State Variables
            APP_STATE: 'AOD_LOCK', 
            isListening: false,     
            MATCHES: [], 
            HISTORY: [], 
            CURRENT_POSITION_INDEX: 0, 
            recognizer: null,

            // D4 Shape Definitions
            LETTER_SHAPES: {
                1: new Set('AEFHIKLMNTVWXYZ'.split('')), 
                2: new Set('BDGJPRU'.split('')), 
                3: new Set('COS'.split('')), 
            },

            // D4 Trigger Words
            D4_TRIGGERS: {
                'WORD': 1, 'WORDS': 1,
                'DIFFERENT': 2,
                'OPTION': 3, 'OPTIONS': 3,
            },

            // Spelled-out numbers mapping (made more comprehensive)
            NUMBER_WORDS: {
                'ONE': 1, 'TWO': 2, 'THREE': 3, 'FOUR': 4, 
                'FIVE': 5, 'SIX': 6, 'SEVEN': 7, 'EIGHT': 8, 'NINE': 9,
                // Added robustness for common recognition errors
                'WAN': 1, 'TOO': 2, 'FOR': 4, 'WON': 1,
            },

            // SVG Icons
            ICON_GEAR_SVG: `<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M12 20v-8M20 12h-8M4 12h8M12 4v8M18.36 5.64l-4.24 4.24M5.64 18.36l4.24-4.24M18.36 18.36l-4.24-4.24M5.64 5.64l4.24 4.24"></path></svg>`,
            ICON_MIC_SVG: `<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M12 1a3 3 0 0 0-3 3v8a3 3 0 0 0 6 0V4a3 3 0 0 0-3-3z"></path><path d="M19 10v2a7 7 0 0 1-14 0v-2"></path><line x1="12" y1="19" x2="12" y2="23"></line><line x1="8" y1="23" x2="16" y2="23"></line></svg>`,
            ICON_CHAT_SVG: `<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 15a2 2 0 0 1-2 2H7l-4 4V5a2 2 0 0 1 2-2h14a2 2 0 0 1 2 2z"></path></svg>`,

            // --- UI/Helper Functions ---
            
            logStatus(message, isError = false) {
                if (isError) {
                    console.error(`[MagicApp ERROR] ${message}`);
                } else {
                    console.log(`[MagicApp] ${message}`);
                }
            },
            
            updateTime() {
                const now = new Date();
                
                let hours = now.getHours();
                const minutes = now.getMinutes().toString().padStart(2, '0');
                
                hours = hours % 12;
                hours = hours ? hours : 12; 
                
                const time = `${hours}:${minutes}`; 
                const date = now.toLocaleDateString('en-US', { weekday: 'long', month: 'long', day: 'numeric' });

                document.getElementById('aod-time').textContent = time;
                document.getElementById('aod-date').textContent = date;
            },

            getVowelIndices(word) {
                const indices = [];
                for (let i = 0; i < word.length; i++) {
                    // Check for uppercase vowels
                    if (word[i].toUpperCase().match(/[AEIOU]/)) {
                        indices.push(i + 1); // 1-based position
                    }
                }
                return indices;
            },

            // --- Voice Recognition Control (Continuous Listening) ---
            startListening() {
                // Only start if we are not already listening
                if (this.isListening) return; 

                this.isListening = true;
                this.APP_STATE = 'AOD_LISTENING';
                this.updateListeningUI(true); // New UI call
                try {
                    // Attempt to stop anything lingering, then start
                    this.recognizer.stop(); 
                    this.recognizer.start();
                    this.logStatus("Started continuous listening session.");
                } catch (e) {
                    this.logStatus(`Error starting recognition: ${e.message}`, true);
                    this.isListening = false;
                    this.updateListeningUI(false);
                }
            },
            
            stopListening() {
                this.isListening = false;
                this.APP_STATE = 'AOD_DISPLAY_FINAL'; // Default state after processing a command
                this.updateListeningUI(false); // New UI call
                try {
                    this.recognizer.stop();
                    this.logStatus("Stopped continuous listening.");
                } catch (e) {}
            },

            updateListeningUI(isActive) {
                const notifIcon = document.getElementById('notif-icon');
                const notifText = document.getElementById('notif-text');
                if (isActive) {
                    notifIcon.innerHTML = this.ICON_MIC_SVG;
                    notifIcon.classList.add('listening-active');
                    notifText.textContent = "Listening for Code...";
                } else {
                    notifIcon.classList.remove('listening-active');
                    // Only update text/icon if we are fully resetting to the initial lock state
                    if (this.APP_STATE === 'AOD_LOCK') {
                        notifIcon.innerHTML = this.ICON_GEAR_SVG;
                        notifText.textContent = "System Update Available";
                    }
                }
            },

            initVoiceRecognition() {
                const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;

                if (!SpeechRecognition) {
                    this.logStatus("Speech Recognition not supported.", true);
                    return;
                }
                
                this.recognizer = new SpeechRecognition();
                this.recognizer.continuous = false; 
                this.recognizer.interimResults = false;
                this.recognizer.lang = 'en-US'; 
                
                this.recognizer.onstart = () => { this.logStatus("Recognizing..."); this.updateListeningUI(true);};

                // Auto-restart logic
                this.recognizer.onend = () => {
                    // Check if we are still supposed to be listening (i.e., we didn't process a command)
                    if (this.isListening && this.APP_STATE === 'AOD_LISTENING') {
                        setTimeout(() => {
                            if (this.isListening) {
                                this.logStatus("Auto-restarting listening...");
                                try {
                                    this.recognizer.start();
                                } catch (e) {
                                    this.logStatus(`Restart error: ${e.message}`, true);
                                    this.updateListeningUI(false);
                                }
                            }
                        }, this.RESTART_DELAY_MS); 
                    } else {
                        this.logStatus("Listening ended normally/processed command.");
                        this.updateListeningUI(false);
                    }
                };

                this.recognizer.onerror = (event) => {
                    this.logStatus(`Voice Error (${event.error}).`, true);
                    if (event.error === 'network' || event.error === 'not-allowed' || event.error === 'service-not-allowed') {
                        this.isListening = false;
                        this.updateListeningUI(false);
                    }
                };
                
                this.recognizer.onresult = (event) => {
                    const transcript = event.results[0][0].transcript.toUpperCase().trim();
                    this.logStatus(`RAW Transcript received: "${transcript}"`);
                    
                    // Stop the current recognition loop immediately after receiving a result
                    this.isListening = false; 
                    this.recognizer.stop(); 
                    
                    if (this.MATCHES.length === 0) {
                        this.handleInitialPasscode(transcript);
                    } else {
                        this.handleLetterInput(transcript);
                    }
                };
            },
            
            // --- Double Tap Handler ---
            handleDoubleTap(event) {
                const target = event.target.closest('#aod-time'); 
                if (!target) return;

                const currentTime = new Date().getTime();
                const timeSinceLastTap = currentTime - this.LAST_TAP_TIME;
                this.LAST_TAP_TIME = currentTime;

                if (timeSinceLastTap < this.DOUBLE_TAP_THRESHOLD) {
                    event.preventDefault(); 
                    
                    if (this.APP_STATE === 'AOD_LOCK' || this.APP_STATE === 'AOD_DISPLAY_FINAL') {
                        // Reset everything and start listening for a new code
                        this.resetApp(false); 
                        if (this.recognizer) {
                            this.startListening();
                            this.LAST_TAP_TIME = 0; 
                        }
                    } 
                }
            },

            // --- Core Logic (Filter functions) ---
            filterDictionary(d1, d2, d3, d4, initialList) {
                if (!Array.isArray(initialList) || initialList.length === 0) { return []; } 
                
                const dictionary = initialList.map(w => w.toUpperCase());
                
                return dictionary.filter(word => {
                    const length = word.length;
                    const vIndices = this.getVowelIndices(word);
                    const firstLetter = word[0];

                    if (length !== d1) return false;
                    
                    // D2 (First Vowel Position)
                    if (d2 > 0 && (vIndices.length < 1 || vIndices[0] !== d2)) return false;
                    
                    // D3 (Second Vowel Position)
                    if (d3 > 0 && (vIndices.length < 2 || vIndices[1] !== d3)) return false;
                    
                    // D4 (First Letter Shape)
                    if (d4 > 0) {
                        const shapeSet = this.LETTER_SHAPES[d4];
                        if (!shapeSet || !shapeSet.has(firstLetter)) return false;
                    }
                    return true;
                });
            },
            
            getDisambiguationIndex(matches) {
                if (matches.length <= 1) return -1;
                const minLength = Math.min(...matches.map(w => w.length));
                let bestIndex = -1;
                let maxUniqueLetters = 1; 
                
                // Iterates through positions 1 to minLength
                for (let i = 0; i < minLength; i++) {   
                    const lettersAtPosition = matches
                        .map(word => word.length > i ? word[i] : null)
                        .filter(l => l !== null);
                    if (lettersAtPosition.length === 0) continue;
                    const uniqueLetters = new Set(lettersAtPosition);

                    // We are looking for the position with the most unique letters
                    if (uniqueLetters.size > maxUniqueLetters) {
                        maxUniqueLetters = uniqueLetters.size;
                        bestIndex = i + 1; 
                    }
                    // If we find 3 or more unique letters, that's often good enough
                    if (maxUniqueLetters >= 3) break; 
                }
                return bestIndex;
            },

            // --- Handlers ---
            
            handleInitialPasscode(transcript) {
                let d4 = 0;
                let numbers = [];
                const words = transcript.split(' ').map(w => w.trim()).filter(w => w.length > 0);
                
                // 1. Collect all numbers and find D4 trigger in a single pass
                for (const w of words) {
                    // Check for D4 trigger
                    const triggerValue = this.D4_TRIGGERS[w];
                    if (triggerValue) {
                        d4 = triggerValue;
                    }

                    // Check for numeric value (spelled-out or single digit)
                    const spelled = this.NUMBER_WORDS[w];
                    if (spelled) {
                        numbers.push(spelled);
                        continue;
                    } 
                    
                    // Check if the word is a string of 1, 2, or 3 digits (e.g., "724")
                    if (w.length >= 1 && w.length <= 3 && /^\d+$/.test(w)) {
                        // Break concatenated digits into separate numbers
                        for (const digitChar of w) {
                            const digit = parseInt(digitChar, 10);
                            if (digit > 0) {
                                numbers.push(digit);
                            }
                        }
                        continue;
                    }
                }
                
                // We only need the last three numbers found
                if (numbers.length > 3) {
                    numbers = numbers.slice(numbers.length - 3);
                }

                if (d4 === 0 || numbers.length !== 3) {
                    this.logStatus(`Initial passcode failed to process. Digits found: ${numbers.length} (${numbers.join(', ')}), D4: ${d4}. Showing transcript before re-starting.`);
                    
                    this.showFailedTranscript(transcript);

                    setTimeout(() => {
                        this.updateListeningUI(false);
                        this.startListening();
                    }, this.TRANSCRIPT_DISPLAY_DURATION);
                    return; 
                }
                
                const [d1, d2, d3] = numbers;
                
                this.logStatus(`PASSCODE PARSED: D1=${d1}, D2=${d2}, D3=${d3}, D4=${d4}`);

                if (typeof LARGE_DICTIONARY === 'undefined' || LARGE_DICTIONARY.length === 0) { 
                    this.logStatus("Dictionary not loaded or is empty. Cannot run filter.", true); 
                    this.resetApp(true);
                    return; 
                }

                const matches = this.filterDictionary(d1, d2, d3, d4, LARGE_DICTIONARY);

                // --- STRICT MATCHING LOGIC ---
                if (matches.length === 0) {
                    this.logStatus("Code filtered to 0 matches. Re-starting listening for a new code.");
                    // Immediately re-start listening without changing UI (timer remains 00, notification remains "Listening...")
                    this.startListening(); 
                    return; 
                }
                // --- END STRICT MATCHING ---

                this.HISTORY = []; 
                this.HISTORY.push(matches);
                this.MATCHES = matches;

                this.logStatus(`Code: ${d1}${d2}${d3}${d4}. Filtered Matches: ${matches.length}`);
                
                this.checkMatchesAndProceed();
            },
            
            handleLetterInput(transcript) {
                // Mic automatically stopped after onresult, but we restart it if we need more input
                this.isListening = false;
                
                if (this.MATCHES.length <= 1) {
                    this.startListening(); 
                    return;
                }
                
                const trigger = "INTERESTING";
                const triggerIndex = transcript.indexOf(trigger);
                
                if (triggerIndex === -1) {
                    this.logStatus("No 'interesting' trigger. Re-starting listening.");
                    this.startListening(); 
                    return;
                }
                
                // Look for the last word before the trigger
                const preTrigger = transcript.substring(0, triggerIndex).trim();
                const preWords = preTrigger.split(' ').filter(w => w.length > 0);
                
                if (preWords.length === 0) {
                    this.logStatus("No word found before 'interesting'. Re-starting listening.");
                    this.startListening(); 
                    return;
                }
                
                const spokenWord = preWords[preWords.length - 1];
                const magicLetter = spokenWord[0].toUpperCase();
                const pos = this.CURRENT_POSITION_INDEX - 1; // 0-based index

                const filtered = this.MATCHES.filter(word => 
                    word.length > pos && word[pos] === magicLetter
                );

                if (filtered.length === 0) {
                    this.logStatus(`Filter failed: Letter '${magicLetter}' at position ${this.CURRENT_POSITION_INDEX} yielded 0 matches. Reverting to previous list.`);
                    this.showFailedTranscript(transcript);
                    setTimeout(() => this.checkMatchesAndProceed(), this.TRANSCRIPT_DISPLAY_DURATION);
                    return;
                }

                this.HISTORY.push(filtered);
                this.MATCHES = filtered;
                this.logStatus(`Filtered by letter '${magicLetter}' at position ${this.CURRENT_POSITION_INDEX}. ${filtered.length} matches remain.`);

                this.checkMatchesAndProceed();
            },

            // --- State and UI Update ---
            showFailedTranscript(transcript) {
                const notifIcon = document.getElementById('notif-icon');
                const notifText = document.getElementById('notif-text');
                
                notifIcon.innerHTML = this.ICON_MIC_SVG; 
                notifIcon.classList.remove('listening-active');

                notifText.innerHTML = `<span style="color: #F8F8F8; font-weight: 700;">DIDN'T PARSE:</span> ${transcript.toLowerCase()}`;
            },

            updateNotification(status) {
                const notifIcon = document.getElementById('notif-icon');
                const notifText = document.getElementById('notif-text');
                const currentSecond = document.getElementById('current-second');

                if (status === 'FINAL') {
                    const finalWord = this.MATCHES[0];
                    this.stopListening(); // Fully stop recognition
                    notifIcon.innerHTML = this.ICON_CHAT_SVG; 
                    notifText.innerHTML = `Sohan wants <span class="final-word-placeholder">${finalWord}</span> to...`;
                    currentSecond.textContent = '00';
                } else if (status === 'WORD_LIST' && this.MATCHES.length > 0) {
                    const displayWords = this.MATCHES.slice(0, 4).map(w => w.toLowerCase()).join(', ');
                    const moreText = this.MATCHES.length > 4 ? ` (+${this.MATCHES.length - 4})` : '';
                    
                    notifIcon.innerHTML = this.ICON_CHAT_SVG; 
                    notifText.innerHTML = `To buy: ${displayWords}${moreText}`;
                    
                    // Restart listening for the next letter input (D5, D6, etc.)
                    this.startListening(); 

                } else if (status === 'INITIAL') {
                    this.updateListeningUI(false);
                    notifText.textContent = "System Update Available";
                }
            },

            checkMatchesAndProceed() {
                
                if (this.MATCHES.length === 1) {
                    this.APP_STATE = 'AOD_DISPLAY_FINAL';
                    this.updateNotification('FINAL');
                    this.logStatus(`FINAL WORD FOUND: ${this.MATCHES[0]}`);
                    
                } else if (this.MATCHES.length > 1) {
                    const bestIndex = this.getDisambiguationIndex(this.MATCHES);

                    if (bestIndex === -1) {
                        this.logStatus(`Ambiguous State: ${this.MATCHES.length} matches. Cannot proceed beyond current filter.`, true);
                        this.CURRENT_POSITION_INDEX = 0; // Reset position, but keep list
                        this.updateNotification('WORD_LIST'); // Display list and restart mic
                        return;
                    }
                    
                    this.CURRENT_POSITION_INDEX = bestIndex;
                    
                    // Update Music Player (0:XX) to the required disambiguation position
                    document.getElementById('current-second').textContent = bestIndex.toString().padStart(2, '0');
                    
                    this.updateNotification('WORD_LIST'); // Display list and restart mic
                    
                } else {
                    // This path should ideally not be hit if handleInitialPasscode/handleLetterInput works correctly
                    this.resetApp(true);
                }
            },
            
            resetApp(returnToLock = true) {
                this.stopListening();
                this.MATCHES = [];
                this.HISTORY = [];
                this.CURRENT_POSITION_INDEX = 0;
                document.getElementById('current-second').textContent = '00';
                
                if (returnToLock) {
                    this.APP_STATE = 'AOD_LOCK';
                    this.updateNotification('INITIAL');
                    this.logStatus("App reset to AOD_LOCK state.");
                } else {
                    // Prepares for a new voice command without going back to "System Update Available"
                    this.APP_STATE = 'AOD_LISTENING';
                    this.logStatus("App state cleared, ready for new voice input.");
                }
            },
            
            // --- PWA Service Worker Registration ---
            registerServiceWorker() {
                if ('serviceWorker' in navigator) {
                    window.addEventListener('load', () => {
                        navigator.serviceWorker.register('./sw.js')
                            .then(reg => console.log('Service Worker registered.', reg.scope))
                            .catch(err => console.error('Service Worker registration failed:', err));
                    });
                }
            },

            // --- Initialization ---
            init() {
                if (typeof LARGE_DICTIONARY === 'undefined' || LARGE_DICTIONARY.length === 0) {
                    this.logStatus("FATAL: Dictionary not accessible or is empty. Functionality limited.", true);
                    document.getElementById('notif-text').textContent = "ERROR: DICT NOT AVAILABLE";
                } else {
                    this.logStatus(`App ready. Dictionary size: ${LARGE_DICTIONARY.length}. Double-tap time to start.`);
                }
                
                this.initVoiceRecognition();
                this.updateTime();
                setInterval(() => this.updateTime(), 1000);   
                
                const timeElement = document.getElementById('aod-time');
                timeElement.addEventListener('click', (e) => this.handleDoubleTap(e));
                timeElement.addEventListener('touchstart', (e) => this.handleDoubleTap(e));
                
                this.updateNotification('INITIAL');
                this.registerServiceWorker();
            }
        };

        window.onload = () => APP.init();
    </script>
</body>
</html>

